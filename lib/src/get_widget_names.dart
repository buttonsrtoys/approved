import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as p;

import 'package:analyzer/dart/analysis/context_builder.dart';
import 'package:analyzer/dart/analysis/context_locator.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:approved/src/common.dart';

final _resourceDir = Directory(resourceLocalPath);
final _widgetNamesPath = '${_resourceDir.path}/class_names.txt';

Future<Set<String>> getWidgetNames() async {
  final resultCompleter = Completer<Set<String>>();

  isWidgetNamesFileFresh().then((isFileFresh) {
    if (isFileFresh) {
      readWidgetsFile(_widgetNamesPath).then((widgetNames) {
        resultCompleter.complete(widgetNames);
      });
    } else {
      final libPath = p.join(Directory.current.absolute.path,'lib');
      stdout.write("package:approved: searching for class names in $libPath...");
      extractWidgetNames(libPath).then((widgetsList) {
        if (!_resourceDir.existsSync()) {
          _resourceDir.createSync();
        }
        _resourceDir.createSync();
        final widgetsFile = File(_widgetNamesPath);
        widgetsFile.createSync();
        const header = '''
# This file was autogenerated by package:approved. Please do not edit.
# Below is a list of class found in the project /lib folder.''';
        final widgetNamesString = widgetsList.join('\n').endWithNewline;
        widgetsFile.writeAsStringSync('$header\n$widgetNamesString');
        stdout.write('done\n');
        resultCompleter.complete(widgetsList);
      });
    }
  });

  return resultCompleter.future;
}

String loadWidgetNames() {
  late String result;
  final widgetNamesFile = File(_widgetNamesPath);
  if (widgetNamesFile.existsSync()) {
    result = widgetNamesFile.readAsStringSync();
  }
  return result;
}

/// Crawls the project and extracts widget names.
Future<Set<String>> extractWidgetNames(String libPath) async {
  final completer = Completer<Set<String>>();

  final contextLocator = ContextLocator();
  final contextRoots = contextLocator.locateRoots(includedPaths: [libPath]);

  final contextBuilder = ContextBuilder();
  getFlutterSdkPath().then((path) {
    final dartStr = p.join(path,'bin','cache','dart-sdk');
    final analysisContext = contextBuilder.createContext(
      contextRoot: contextRoots.first,
      sdkPath: dartStr,
    );

    final classNames = <String>{};

    // Traverse all files in the lib folder
    final libDirectory = Directory(libPath);
    final dartFiles = libDirectory.listSync(recursive: true).where((file) =>
        file.path.endsWith('.dart') && !file.path.contains('.g.dart') && !file.path.contains('.freezed.dart'));

    for (final file in dartFiles) {
      final analysisSession = analysisContext.currentSession;
      final parsedResult = analysisSession.getParsedUnit(file.path) as ParsedUnitResult;

      for (final compilationUnitMember in parsedResult.unit.declarations) {
        if (compilationUnitMember is ClassDeclaration) {
          final String name = compilationUnitMember.name.value().toString();
          if (!name.startsWith('_')) {
            classNames.add(name);
          }
        }
      }
    }

    completer.complete(classNames);
  });

  return completer.future;
}

/// Get the path to the Flutter SDK
Future<String> getFlutterSdkPath() async {
  final completer = Completer<String>();

  Process.run(Platform.isWindows? 'flutter.bat': 'flutter', ['--version', '--machine']).then((result) {
    if (result.exitCode != 0) {
      throw Exception('Failed to run flutter command: ${result.stderr}');
    }

    final jsonData = jsonDecode(result.stdout);

    completer.complete(jsonData['flutterRoot']);
  });

  return completer.future;
}

Future<Set<String>> readWidgetsFile(String filePath) async {
  final completer = Completer<Set<String>>();
  File file = File(filePath);

  file.readAsString().then((text) {
    // Split by lines
    final linesList = text.split('\n');
    // Remove empty lines and comments
    final linesSet = linesList.where((line) => line.isNotEmpty && !line.startsWith('#')).toSet();
    completer.complete(linesSet);
  });

  return completer.future;
}

Future<bool> isWidgetNamesFileFresh() async {
  final resultCompleter = Completer<bool>();

  final libDirectory = Directory('lib');

  findNewestDartFileTimestamp(libDirectory).then((dateTime) {
    final widgetNamesFile = File(_widgetNamesPath);
    if (dateTime != null && widgetNamesFile.existsSync() && widgetNamesFile.lastModifiedSync().isAfter(dateTime)) {
      resultCompleter.complete(true);
    } else {
      resultCompleter.complete(false);
    }
  });

  return resultCompleter.future;
}

Future<DateTime?> findNewestDartFileTimestamp(Directory dir) async {
  DateTime? newestTimestamp;

  if (!await dir.exists()) {
    return null;
  }

  await for (FileSystemEntity entity in dir.list(recursive: true)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      DateTime lastModified = await entity.lastModified();

      if (newestTimestamp == null || lastModified.isAfter(newestTimestamp)) {
        newestTimestamp = lastModified;
      }
    }
  }

  return newestTimestamp;
}
